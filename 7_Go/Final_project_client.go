package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strconv"
	"sync"
	"time"
)

// Пункт 5. Каждый клиент имеет по 2 воркера и каждый может отправлять по 5 запросов на сервер.
// По завершению отправки, каждый клиент должен выводить статистику:
// Отправлено запросов: #
// Разбивка по статусам: 200 - #, 400 - #, 500 - # и тд

// Создаются константы:
// totalRequestsPerClient - Каждый клиент отправляет 100 запросов.
// workersPerClient - У каждого клиента 2 воркера.
// requestsPerWorker - Каждый воркер отправляет 50 запросов.
// clientRateLimit - Ограничение на 5 запросов в секунду для каждого воркера.
const (
	totalRequestsPerClient = 100
	workersPerClient       = 2
	requestsPerWorker      = totalRequestsPerClient / workersPerClient
	clientRateLimit        = time.Second / 5
)

// Создаются две горутины для клиентов, отправляющих по 100 POST-запросов (каждый с 2 воркерами).
// Запускается горутина для мониторинга состояния сервера (каждые 5 секунд).
// Ожидается завершение работы горутин клиентов.
// После завершения отправки запросов запрашивается и выводится итоговая статистика сервера.
func main() {
	// Пункт 3. Необходимо написать 3 клиентов
	// Первый и второй клиент будут в горутинах слать по 100 POST запросов на сервер.
	// Третий клиент будет с каждые 5 секунд проверять состояние сервера. Доступен или нет.

	// Объект для ожидания завершения горутин.
	var wg sync.WaitGroup

	// Цикл for для создания двух клиентов.
	// Формируется идентификатор клиента (Клиент-1, Клиент-2...).
	// Увеличивается счётчик ожидания.
	// Запускается горутина для работы конкретного клиента.
	// По завершении горутины счётчик уменьшается.
	// Вызывается функция отправки запросов от клиента.
	for i := 1; i <= 2; i++ {
		clientID := "Клиент-" + strconv.Itoa(i)
		wg.Add(1)
		go func(id string) {
			defer wg.Done()
			sendClientRequests(id)
		}(clientID)
	}

	// Запускается горутина для мониторинга состояния сервера.
	// Каждые 5 секунд отправляется GET-запрос к серверу для получения текущей статистики.
	go monitorServer()
	// Ожидается завершение работы горутин клиентов.
	wg.Wait()
	// После завершения работы клиентов запрашивается и выводится итоговая статистика сервера.
	fetchAndPrintServerStats()
}

// Часть 5 пункта

// Функция sendClientRequests создает 2 воркера для отправки запросов от одного клиента.
// Создается канал для сбора статистики от воркеров.
// Запускаются 2 воркера, каждый из которых отправляет 50 запросов.
// После завершения работы воркеров статистика агрегируется и выводится.
func sendClientRequests(clientID string) {
	var wg sync.WaitGroup
	statsChannel := make(chan map[int]int, workersPerClient)

	// Цикл for для запуска 2-х воркеров.
	// Увеличивается счётчик ожидания.
	// Запускается горутина для работы конкретного воркера.
	// По завершении работы воркера счётчик уменьшается.
	// Вызывается функция отправки запросов от воркера, и ее результат отправляется в канал.
	for w := 1; w <= workersPerClient; w++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()
			statsChannel <- sendRequestsWorker(clientID, workerID)
		}(w)
	}

	// Ожидается завершение работы всех воркеров.
	wg.Wait()
	// Канал закрывается, так как данные собраны.
	close(statsChannel)
	// Создается карта для агрегирования статистики от всех воркеров.
	totalStats := make(map[int]int)
	// Полученная статистика из канала обрабатывается -
	// для каждого HTTP-кода суммируется количество запросов.
	for stats := range statsChannel {
		for code, count := range stats {
			totalStats[code] += count
		}
	}

	// Вывод итоговой статистики для данного клиента.
	fmt.Printf("%s: Отправил %d запросов. Статистика: %v\n", clientID, totalRequestsPerClient, totalStats)
}

// Функция sendRequestsWorker отправляет запросы от одного воркера.
// Создается HTTP-клиент, и с помощью таймера (переименован в fiveRequestsTimer)
// ограничивается отправка запросов до 5 в секунду.
// Отправляется POST-запрос к серверу с заголовком "Client-ID" для идентификации запроса.
// Полученный HTTP-ответ анализируется, и статистика обновляется.
func sendRequestsWorker(clientID string, workerID int) map[int]int {
	// Создается карта для хранения статистики.
	stats := make(map[int]int)
	// Создается HTTP-клиент для отправки запросов.
	httpClient := &http.Client{}
	// Создается таймер для ограничения 5 запросов в секунду.
	fiveRequestsTimer := time.NewTicker(clientRateLimit)
	// По завершении работы воркера таймер останавливается.
	defer fiveRequestsTimer.Stop()

	// Цикл for для отправки заданного количества запросов (по условию задачи - 50) от данного воркера.
	// При каждом срабатывании таймера отправляется POST-запрос к серверу.
	// Заголовок "Client-ID" устанавливается для идентификации запроса.
	// Полученный HTTP-ответ анализируется, и статистика обновляется.
	for i := 0; i < requestsPerWorker; i++ {
		<-fiveRequestsTimer.C // Ожидается срабатывание таймера (ограничение 5 запросов/сек).
		req, _ := http.NewRequest("POST", "http://localhost:8080/request", nil)
		req.Header.Set("Client-ID", clientID)
		resp, _ := httpClient.Do(req)
		stats[resp.StatusCode]++
		resp.Body.Close()
	}
	// Возвращается собранная статистика для данного воркера.
	return stats
}

// Функция monitorServer каждые 5 секунд запрашивает у сервера статистику.
// Отправляется GET-запрос к серверу, читается тело ответа,
// и полученные актуальные данные о работе сервера статистики выводится в лог.
func monitorServer() {
	for {
		time.Sleep(5 * time.Second)
		resp, _ := http.Get("http://localhost:8080/stats")
		body, _ := ioutil.ReadAll(resp.Body)
		resp.Body.Close()
		log.Println("Сервер работает! Текущая статистика:", string(body))
	}
}

// Функция fetchAndPrintServerStats запрашивает итоговую статистику сервера и выводит ее в консоль.
// Создается HTTP-клиент, отправляется GET-запрос к серверу для получения статистики,
// читается тело ответа, и полученная статистика выводится на экран.
func fetchAndPrintServerStats() {
	httpClient := &http.Client{}
	resp, _ := httpClient.Get("http://localhost:8080/stats")
	body, _ := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	fmt.Println("Финальная статистика:\n", string(body))
}

// Всё! УРА!!! УРА!!! УРААА!!!
// Спасибо вам за помощь в нашем обучении
// А в частности проверке материалов)
// Всего вам доброго)
